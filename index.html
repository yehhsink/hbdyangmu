<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Birthday Mystery Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; }
        canvas { display: block; outline: none; }
        
        /* UI & Loader */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #020205; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 1000;
            color: #b3e5fc; font-family: 'Segoe UI', sans-serif; transition: opacity 1s ease;
        }
        .spinner {
            width: 50px; height: 50px; border: 4px solid #333;
            border-top: 4px solid #b3e5fc; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #ui-layer {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            pointer-events: none; user-select: none; z-index: 500;
        }
        .instruction {
            color: #e1f5fe; font-family: 'Segoe UI', sans-serif; font-size: 18px;
            text-shadow: 0 0 10px #0288d1; letter-spacing: 1px;
            background: rgba(0,0,0,0.5); padding: 12px 25px; border-radius: 30px;
            display: inline-block; backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2); transition: all 0.5s;
        }

        /* Hidden Video Input for AI */
        #input_video { display: none; }
    </style>

    <!-- Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- NEW FEATURE: Background Music (Looping) -->
    <!-- Using a reliable Google Sound Library URL for demo purposes -->
    <audio id="bgm" loop>
    <source src="hbd.mp3" type="audio/mpeg">
</audio>

    <video id="input_video"></video>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loading-text">Initializing Magic & Audio...</div>
        <div style="font-size: 0.85rem; margin-top: 15px; color: #888;">(Please Allow Camera Access)</div>
    </div>

    <div id="ui-layer">
        <div id="instr-text" class="instruction">Loading...</div>
    </div>

    <script>
        /**
         * --- CONFIGURATION ---
         */
        const CONFIG = {
            colors: {
                bg: 0x050510,
                treeParticles: 0xe1f5fe, // Icy Silver/White
                star: 0xffffee,
                starGlow: 0xffffff,
                // Pale Purple / Light Violet Text Aesthetic
                text: "rgba(225, 190, 231, 0.95)", 
                gifts: [0xD32F2F, 0x1565C0, 0xF9A825, 0x2E7D32, 0x6A1B9A, 0x0097A7]
            },
            prizes: [
                "ç”Ÿæ—¥å¿«ä¹ï¼è¿™é‡Œæ˜¯ä¸€ç­‰å¥–", 
                "ç”Ÿæ—¥å¿«ä¹ï¼è¿™é‡Œæ˜¯äºŒç­‰å¥–", 
                "ç”Ÿæ—¥å¿«ä¹ï¼è¿™é‡Œæ˜¯ä¸‰ç­‰å¥–", 
                "ç”Ÿæ—¥å¿«ä¹ï¼è¿™é‡Œæ˜¯å››ç­‰å¥–", 
                "ç”Ÿæ—¥å¿«ä¹ï¼è¿™é‡Œæ˜¯äº”ç­‰å¥–", 
                "ç”Ÿæ—¥å¿«ä¹ï¼è¿™é‡Œæ˜¯å…­ç­‰å¥–"
            ],
            loserMsg: "Sorry, å†æ¥ä¸€æ¬¡~",
            finalMsg: "Happy Birthday, æ¨å¥³å£«~"
        };

        // --- GLOBAL STATE ---
        let scene, camera, renderer, controls;
        let gifts = []; 
        let particles, starMesh;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let clock = new THREE.Clock();
        
        let gameStarted = false; 
        let uniqueWinnersFound = 0;
        let foundWinnerIds = new Set();
        
        // 1. RANDOMIZATION (Fisher-Yates)
        let prizePool = [...CONFIG.prizes, ...Array(6).fill(CONFIG.loserMsg)];
        for (let i = prizePool.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [prizePool[i], prizePool[j]] = [prizePool[j], prizePool[i]];
        }

        init3D();
        initMediaPipe();
        animate();

        /**
         * 1. THREE.JS SCENE SETUP
         */
        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.012);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 90);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // Controls (Optimized Sensitivity)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableRotate = false; // Locked until gesture
            controls.enablePan = false;
            controls.enableZoom = true;
            controls.enableDamping = true; // Smooth motion
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 0.6;    // Optimized
            controls.zoomSpeed = 0.8;      // Optimized
            controls.minDistance = 30;
            controls.maxDistance = 120;
            controls.target.set(0, 30, 0);

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const pLight = new THREE.PointLight(0xe0f7fa, 1, 100);
            pLight.position.set(30, 50, 50);
            scene.add(pLight);

            // Objects
            createIcyTree();
            createStarTopper();
            createShootingStarsSystem(); 
            createGifts();

            window.addEventListener('resize', onResize);
            window.addEventListener('click', onClick);
        }

        /**
         * 2. OBJECT GENERATION
         */
        function createIcyTree() {
            const geom = new THREE.BufferGeometry();
            const count = 3000;
            const positions = [];
            const colors = [];
            const colorObj = new THREE.Color(CONFIG.colors.treeParticles);
            
            for(let i=0; i<count; i++) {
                const r = i/count;
                const angle = i * 0.15;
                const h = r * 70;
                const radius = (1-r) * 28;
                
                const x = Math.cos(angle)*radius + (Math.random()-0.5)*2;
                const z = Math.sin(angle)*radius + (Math.random()-0.5)*2;
                
                positions.push(x, h, z);
                colors.push(colorObj.r, colorObj.g, colorObj.b);
            }
            
            geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const mat = new THREE.PointsMaterial({
                size: 1.0, vertexColors: true, transparent: true, opacity: 0.9,
                blending: THREE.AdditiveBlending, map: getDiscTexture(), depthWrite: false
            });

            particles = new THREE.Points(geom, mat);
            particles.position.y = -5;
            scene.add(particles);
        }

        function createStarTopper() {
            const geo = new THREE.OctahedronGeometry(2.5, 0);
            const mat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.star });
            starMesh = new THREE.Mesh(geo, mat);
            starMesh.position.set(0, 68, 0);
            
            const spriteMat = new THREE.SpriteMaterial({ 
                map: getGlowTexture(), color: CONFIG.colors.starGlow, 
                transparent: true, blending: THREE.AdditiveBlending 
            });
            const glow = new THREE.Sprite(spriteMat);
            glow.scale.set(20, 20, 1);
            starMesh.add(glow);

            new TWEEN.Tween(glow.scale).to({x:25, y:25}, 1500).yoyo(true).repeat(Infinity).start();
            scene.add(starMesh);
        }

        function createGifts() {
            const count = 12;
            const treeHeight = 60;

            for(let i=0; i<count; i++) {
                const group = new THREE.Group();

                // --- PLACEMENT: VISIBLE OUTER LAYER ---
                const r = i/count; 
                const h = r * (treeHeight - 12) + 5; 
                // Tree radius at height h = (1 - h/70) * 28
                // Add 5 units to ensure visibility on outside
                const placementRadius = ((1 - (h/70)) * 28) + 5; 

                const angle = i * 2.4; // Spiral
                const targetX = Math.cos(angle) * placementRadius;
                const targetZ = Math.sin(angle) * placementRadius;
                const targetY = h - 5; 

                // Initial Pos (Scattered Ground)
                const groundY = -8;
                group.position.set(
                    (Math.random()-0.5)*50, 
                    groundY, 
                    (Math.random()-0.5)*20 + 30
                );

                // --- GIFT VISUALS ---
                const size = 3.5;
                const color = CONFIG.colors.gifts[i % CONFIG.colors.gifts.length];
                const box = new THREE.Mesh(
                    new THREE.BoxGeometry(size, size, size),
                    new THREE.MeshStandardMaterial({ color: color, roughness:0.4, metalness:0.3 })
                );
                group.add(box);

                const ribMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness:0.2 });
                group.add(new THREE.Mesh(new THREE.BoxGeometry(size+0.2, size, 0.8), ribMat));
                group.add(new THREE.Mesh(new THREE.BoxGeometry(0.8, size, size+0.2), ribMat));

                const bow = new THREE.Mesh(
                    new THREE.TorusKnotGeometry(0.8, 0.2, 64, 8),
                    new THREE.MeshStandardMaterial({ color: 0xFFD700 })
                );
                bow.position.y = size/2 + 0.6;
                bow.scale.set(1, 0.5, 1);
                group.add(bow);

                // --- DATA ---
                group.userData = {
                    id: i,
                    message: prizePool[i],
                    isWinner: prizePool[i].includes("ç­‰å¥–"),
                    targetPos: new THREE.Vector3(targetX, targetY, targetZ),
                    groundPos: new THREE.Vector3(group.position.x, groundY, group.position.z),
                    originalY: targetY, 
                    onTree: false 
                };
                
                group.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                scene.add(group);
                gifts.push(group);
            }
        }

        /**
         * 3. MEDIAPIPE GESTURE & START
         */
        function initMediaPipe() {
            const videoElement = document.getElementById('input_video');
            const hands = new Hands({locateFile: (file) => 
                `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.6
            });
            
            hands.onResults((results) => {
                if(gameStarted) return;
                // Gesture: 2 Hands, Wrists High (y < 0.45)
                if(results.multiHandLandmarks && results.multiHandLandmarks.length === 2) {
                    const h1 = results.multiHandLandmarks[0][0].y;
                    const h2 = results.multiHandLandmarks[1][0].y;
                    if(h1 < 0.45 && h2 < 0.45) triggerGameStart();
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            
            cameraUtils.start().then(() => {
                document.getElementById('loading-text').innerText = "System Ready!";
                document.getElementById('instr-text').innerText = "ðŸ™Œ Raise Both Hands to Decorate the Tree! ðŸ™Œ";
                setTimeout(() => {
                    document.getElementById('loader').style.opacity = '0';
                    setTimeout(()=>document.getElementById('loader').style.display='none', 1000);
                }, 800);
            });
        }

        function triggerGameStart() {
            gameStarted = true;
            document.getElementById('instr-text').innerText = "ðŸŽ Click Gifts! Drag to Explore. ðŸŽ";
            
            // NEW FEATURE: PLAY AUDIO AUTOMATICALLY
            const bgm = document.getElementById('bgm');
            bgm.volume = 0.5;
            bgm.play().catch(e => {
                });

            // Unlock Camera
            controls.enableRotate = true;
            controls.enablePan = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;

            // Animate Gifts to Tree
            gifts.forEach((g, i) => {
                g.userData.onTree = true;
                
                new TWEEN.Tween(g.rotation)
                    .to({x:0, y:Math.atan2(g.position.x, g.position.z), z:0}, 1000)
                    .start();

                new TWEEN.Tween(g.position)
                    .to({
                        x: g.userData.targetPos.x,
                        y: g.userData.targetPos.y,
                        z: g.userData.targetPos.z
                    }, 2500)
                    .easing(TWEEN.Easing.Elastic.Out)
                    .delay(i * 100)
                    .start();
            });
        }

        /**
         * 4. INTERACTION LOGIC
         */
        function onClick(event) {
            if(!gameStarted) return;
            controls.autoRotate = false; 

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            if(intersects.length > 0) {
                let obj = intersects[0].object;
                while(obj.parent && obj.parent.type !== 'Scene') {
                    if(obj.userData && obj.userData.id !== undefined) break;
                    obj = obj.parent;
                }

                if(obj.userData && obj.userData.id !== undefined) {
                    handleGiftInteraction(obj);
                }
            }
        }

        function handleGiftInteraction(group) {
            const data = group.userData;

            // Logic: Unique Winners
            if(data.isWinner && !foundWinnerIds.has(data.id)) {
                foundWinnerIds.add(data.id);
                uniqueWinnersFound++;
            }

            // Animation: Shake
            new TWEEN.Tween(group.scale).to({x:1.3, y:1.3, z:1.3}, 150).yoyo(true).repeat(1).start();

            // Show Text & Schedule Return
            showFloatingText(group);
        }

        function showFloatingText(group) {
            if(group.userData.textMesh) group.remove(group.userData.textMesh);
            if(group.userData.timer) clearTimeout(group.userData.timer);

            const sprite = createTextSprite(group.userData.message);
            sprite.position.set(0, 5, 0); 
            sprite.scale.set(0,0,1);
            group.add(sprite);
            group.userData.textMesh = sprite;

            // Pop In
            new TWEEN.Tween(sprite.scale)
                .to({x: sprite.userData.finalScaleX, y: sprite.userData.finalScaleY}, 400)
                .easing(TWEEN.Easing.Back.Out)
                .start();

            // 3 SECONDS LATER...
            group.userData.timer = setTimeout(() => {
                // A. Fade Out Text
                new TWEEN.Tween(sprite.scale)
                    .to({x:0, y:0}, 300)
                    .easing(TWEEN.Easing.Back.In)
                    .onComplete(() => {
                        group.remove(sprite);
                        group.userData.textMesh = null;
                    })
                    .start();

                // B. RETURN TO GROUND 
                // Only if game isn't over yet
                if(uniqueWinnersFound < 6) {
                    animateGiftToGround(group);
                } else {
                    triggerEndGame();
                }
            }, 3000);
        }

        function animateGiftToGround(group) {
            group.userData.onTree = false;
            new TWEEN.Tween(group.position)
                .to({
                    x: group.userData.groundPos.x, 
                    y: group.userData.groundPos.y, 
                    z: group.userData.groundPos.z
                }, 1500)
                .easing(TWEEN.Easing.Bounce.Out)
                .start();
                
            new TWEEN.Tween(group.rotation)
                .to({x: Math.random()*Math.PI, z: Math.random()*Math.PI}, 1500)
                .start();
        }

        function triggerEndGame() {
            // Hide Instructions
            document.getElementById('instr-text').style.opacity = '0';

            // CRITICAL: RENDER END MESSAGE AS PARTICLE SPRITE (Aesthetic Match)
            const finalSprite = createTextSprite(CONFIG.finalMsg, true); // true for extra big
            finalSprite.position.set(0, 10, 50); // Center screen roughly
            finalSprite.scale.set(0, 0, 1);
            scene.add(finalSprite);

            new TWEEN.Tween(finalSprite.scale)
                .to({ x: finalSprite.userData.finalScaleX * 1.5, y: finalSprite.userData.finalScaleY * 1.5 }, 1000)
                .easing(TWEEN.Easing.Elastic.Out)
                .start();

            // All remaining gifts fall
            gifts.forEach((g, i) => {
                if(g.userData.onTree) {
                    setTimeout(() => animateGiftToGround(g), i * 100);
                }
            });
        }

        function createTextSprite(message, isFinal = false) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const fontSize = isFinal ? 70 : 50; 
            const font = `bold ${fontSize}px "Microsoft YaHei", sans-serif`;
            ctx.font = font;
            
            const width = ctx.measureText(message).width + 40;
            const height = fontSize + 40;
            canvas.width = width;
            canvas.height = height;

            // Styling: Pale Purple (Particle form aesthetic)
            ctx.font = font;
            ctx.fillStyle = CONFIG.colors.text;
            ctx.shadowColor = "rgba(255,255,255,0.9)";
            ctx.shadowBlur = 15;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(message, width/2, height/2);

            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, depthTest: false, transparent: true });
            const sprite = new THREE.Sprite(mat);
            
            const ratio = width/height;
            const hWorld = isFinal ? 6 : 4; 
            sprite.userData = { finalScaleX: hWorld * ratio, finalScaleY: hWorld };
            sprite.renderOrder = 999; 
            return sprite;
        }

        /**
         * 5. ENVIRONMENT & LOOPS
         */
        function createShootingStarsSystem() {
            // Static Background
            const geom = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<800; i++) pos.push((Math.random()-0.5)*500, (Math.random()-0.5)*500, -100 + (Math.random()*100));
            geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            scene.add(new THREE.Points(geom, new THREE.PointsMaterial({size:0.6, color:0xffffff})));
        }

        // VISUAL FIX: Direction Top-Right to Bottom-Left
        // OPTIMIZATION: Increased Size & Frequency
        function spawnShootingStar() {
            const len = 60; // Increased Size
            const geo = new THREE.PlaneGeometry(len, 1.2);
            
            const cvs = document.createElement('canvas'); cvs.width=128; cvs.height=32;
            const ctx = cvs.getContext('2d');
            const g = ctx.createLinearGradient(0,0,128,0);
            g.addColorStop(0,"rgba(255,255,255,0)"); // Tail
            g.addColorStop(1,"rgba(255,255,255,1)"); // Head
            ctx.fillStyle=g; ctx.fillRect(0,0,128,32);

            const mat = new THREE.MeshBasicMaterial({
                map: new THREE.CanvasTexture(cvs), transparent: true, opacity: 0,
                side: THREE.DoubleSide, blending: THREE.AdditiveBlending, depthWrite:false
            });

            const mesh = new THREE.Mesh(geo, mat);
            
            // Start: Top Right (High Pos X, High Pos Y)
            const sx = 150 + Math.random() * 200; 
            const sy = 100 + Math.random() * 100;
            mesh.position.set(sx, sy, -120);
            
            // Rotation: Head points diagonal down-left (225 deg)
            mesh.rotation.z = THREE.Math.degToRad(225); 

            scene.add(mesh);

            // Animate to Bottom Left
            const dist = 450;
            
            new TWEEN.Tween(mat).to({opacity:1}, 200).start();
            
            new TWEEN.Tween(mesh.position)
                .to({x: sx - dist, y: sy - dist}, 1200)
                .easing(TWEEN.Easing.Linear.None)
                .onComplete(()=>scene.remove(mesh))
                .start();
                
            new TWEEN.Tween(mat).to({opacity:0}, 300).delay(900).start();
        }

        function getDiscTexture() {
            const c = document.createElement('canvas'); c.width=32; c.height=32;
            const x = c.getContext('2d');
            x.fillStyle='#fff'; x.beginPath(); x.arc(16,16,10,0,6.28); x.fill();
            return new THREE.CanvasTexture(c);
        }
        function getGlowTexture() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const x = c.getContext('2d');
            const g = x.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0,"white"); g.addColorStop(1,"transparent");
            x.fillStyle=g; x.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            controls.update();

            const t = clock.getElapsedTime();
            if(particles) particles.rotation.y = t * 0.05;
            if(starMesh) starMesh.rotation.y = -t * 0.2;

            gifts.forEach(g => {
                if(g.userData.onTree) {
                    g.position.y = g.userData.originalY + Math.sin(t*2 + g.userData.id)*0.4;
                    g.rotation.y += 0.01;
                }
            });

            // High Frequency Stars (0.08 chance per frame)
            if(Math.random() < 0.08) spawnShootingStar();

            renderer.render(scene, camera);
        }
    </script>
</body>

</html>


